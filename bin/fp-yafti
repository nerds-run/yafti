#!/usr/bin/env python
###
# This is just a simple bin to play around with flatpak cli stdout
###
import pprint
import subprocess


FLATPAK_PATH: str = '/usr/bin/flatpak'


def main():
    results = exec_cmd()

    decoded_current = results.decode("utf-8").replace("current packages: ", "")
    headers = ["ref", "name", "runtime", "installation", "version", "options"]

    pkg_list = []
    for p in decoded_current.splitlines():
        turds = p.split("\t")

        with_headers = {headers[i]: t for i, t in enumerate(turds)}
        pkg_list.append(with_headers.copy())

    for i in pkg_list:
        cares = None
        opts = i.get('options')
        if ',' in opts:
            chunks = opts.split(',')
            prefix = chunks[1].strip()
            if prefix == 'current':
                prefix = 'app'

            cares = f"{prefix}/{i.get('ref')}"

        if cares is not None:
            print(cares)
            info = exec_remote_info(i.get('ref').strip())
            pprint.pprint(info)


def exec_cmd():
    results = subprocess.run(
        [FLATPAK_PATH, 'list', '--columns=ref,name,runtime,installation,version,options'],
        capture_output=True
    )

    return results.stdout if results.returncode == 0 else ""


def exec_remote_info(ref: str):
    results = subprocess.run(
        [FLATPAK_PATH, 'remote-info', 'flathub', ref],
        capture_output=True
    )

    decoded_current = results.stdout.decode("utf-8").replace(ref, '')
    pkg_info = {}
    for p in decoded_current.splitlines():
        turds = p.strip().split("\t")
        for t in turds:
            if t:
                chunks = t.split(':')
                if len(chunks) == 2:
                    k, v = t.split(":")
                    pkg_info[k.strip().lower()] = v.strip().lower()
                else:
                    # likely a date, skipping can clean up later
                    continue

    return pkg_info


if __name__ == "__main__":
    main()
